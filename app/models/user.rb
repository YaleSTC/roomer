# frozen_string_literal: true

# User model class for all user types. Optionally loads in sets of Devise
# modules for authentication. Validates presence of required profile fields
# (noted below).
#
# @attr email [String] the user's e-mail (required for database auth)
# @attr encrypted_password [String] the encrypted password for database
#   authentication (handled by Devise)
# @attr username [String] the user's CAS login (required for CAS auth)
# @attr role [Integer] an enum for the user's role: superuser, admin,
#   [housing] rep, or student (required)
# @attr first_name [String] the user's first name (required)
# @attr last_name [String] the user's last name (required)
# @attr class_year [Integer] the graduating class year of the student (required)
# @attr tos_accepted [DateTime] the time of agreement to the terms of service
class User < ApplicationRecord
  # Determine whether or not CAS authentication is being used, must be at the
  # top of the class to be used in the Devise loading conditional below.
  #
  # @return [Boolean] true if the CAS_BASE_URL environment variable is set,
  #   false otherwise
  def self.cas_auth?
    env? 'CAS_BASE_URL'
  end

  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable and :omniauthable
  if cas_auth?
    devise :cas_authenticatable, :trackable
  else
    devise :database_authenticatable, :recoverable, :rememberable, :trackable,
           :validatable
  end

  belongs_to :college
  has_many :draw_memberships, dependent: :destroy
  has_many :draws, through: :draw_memberships
  has_one :draw_membership, -> { where(active: true) }, dependent: :destroy
  has_one :draw, through: :draw_membership
  has_many :memberships, through: :draw_memberships, source: :memberships
  has_many :active_memberships, through: :draw_membership, source: :memberships
  has_one :membership, through: :draw_membership, source: :membership
  has_one :group, through: :membership
  has_one :room_assignment, through: :draw_membership
  has_one :room, through: :draw_membership

  delegate :building_name, to: :room, allow_nil: true
  delegate :name, to: :draw, prefix: :draw, allow_nil: true
  delegate :name, to: :group, prefix: :group, allow_nil: true
  delegate :number, to: :room, prefix: :room, allow_nil: true
  delegate :suite_number, to: :group, allow_nil: true
  delegate :lottery_number, to: :group, allow_nil: true
  delegate :intent, to: :draw_membership, allow_nil: true

  validates :email, uniqueness: true
  validates :username, presence: true, if: :cas_auth?
  validates :username, uniqueness: { case_sensitive: false }, allow_nil: true
  validates :role, presence: true
  validates :first_name, presence: true
  validates :last_name, presence: true
  validates :student_id, uniqueness: { allow_blank: true }
  validates :class_year, presence: true,
                         if: ->() { role == 'student' || role == 'rep' }
  validates :college_id, presence: true, unless: :superadmin?

  enum role: %w(student admin rep superuser superadmin graduated)

  devise :timeoutable, timeout_in: 24.hours

  before_save :downcase_username, if: :cas_auth?

  scope :active, -> { where.not(role: 'graduated') }

  self.table_name = 'shared.users'

  # Return a symbol representing the attribute that represents a user's login
  # credential
  #
  # @return [Symbol] the user's login credential
  def self.login_attr
    cas_auth? ? :username : :email
  end

  # Return a random password generated by Devise
  #
  # @param length [Integer] the length of the password to generate, defaults to
  #   12
  # @return [String] a random password of the specified length
  def self.random_password(length = 12)
    Devise.friendly_token(length)
  end

  # Returns the user's preferred name
  #
  # @return [String] Preferred name
  def name
    first_name
  end

  # Returns the user's preferred full name
  #
  # @return [String] First name plus last name
  def full_name
    "#{name} #{last_name}"
  end

  # Returns the user's full name with their intent in parentheses
  #
  # @return [String] Full name with user's intent in parentheses
  def full_name_with_intent
    "#{full_name} (#{pretty_intent})"
  end

  # Returns the user's intent not in snake case (replaces underscores with
  # spaces)
  #
  # @return [String] the non-snake case intent
  def pretty_intent
    intent.tr('_', ' ')
  end

  # Returns true if the user is the leader of the given group
  #
  # @return [Boolean]
  def leader_of?(group)
    self == group.leader
  end

  # Override #admin? to also return true for superusers
  #
  # @return [Boolean] True for admins, superadmins, and superusers
  def admin?
    super || superadmin?
  end

  # Override #superadmin? to also return true for superusers
  #
  # @return [Boolean] True for superadmins and superusers
  def superadmin?
    super || superuser?
  end

  # Return the login attribute for a user; the username if using CAS or the
  # email otherwise
  def login_attr
    send(self.class.login_attr)
  end

  private

  def downcase_username
    username.downcase!
  end

  def cas_auth?
    User.cas_auth?
  end

  def freeze_tos_acceptance
    return if tos_accepted_in_database.nil?
    handle_abort('Terms of Service acceptance cannot be changed')
  end
end
